#!/usr/bin/python

"""Create Geo spacial test data for the DCCD archive

For each 'test' project it creates a directory and file structure with the DCCD project data that can be uploaded to the DCCD archive using its RESTfull interface.  

Requires:
	docopt
	
Usage:
	create_geotestdata.py [-d DIR]
	create_geotestdata.py ( -h | --help)
	
Options:
	-h --help         Show this screen
	-d DIR            Output directory [default: geodata]
	
"""
from docopt import docopt
import zipfile
import os, sys

#print "Create test data to use for batch ingestion";
# Hardcode everything for now!

outputDirName = "geodata"

""" Construct the metadata xml """
def constructMetadata():
	template = """<?xml version="1.0" encoding="UTF-8"?>
<dccdmetadata>
    <language>nl</language>
    <values>
        <format>Heidelberg</format>
    </values>
</dccdmetadata>
"""
	return template

""" Construct the TRiDaS xml """
def constructTridas(title, lat, lng):
	template = """<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<tridas:tridas xmlns:tridas="http://www.tridas.org/1.2.2" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:gml="http://www.opengis.net/gml">
    <tridas:project>
        <tridas:title>%(title)s</tridas:title>
        <tridas:identifier domain="stichtingring.nl">P:1993041</tridas:identifier>
        <tridas:createdTimestamp>2010-06-30T11:11:41Z</tridas:createdTimestamp>
        <tridas:lastModifiedTimestamp>2010-06-30T11:11:41Z</tridas:lastModifiedTimestamp>
        <tridas:type lang="en" normal="dating" normalId="1522" normalStd="DCCD">datering</tridas:type>
        <tridas:laboratory>
            <tridas:identifier domain="www.cultureelerfgoed.nl">1</tridas:identifier>
            <tridas:name acronym="NLROB">Rijkdsdienst voor het Oudheidkundig Bodemonderzoek</tridas:name>
            <tridas:address>
                <tridas:cityOrTown>Amersfoort</tridas:cityOrTown>
                <tridas:country>Nederland</tridas:country>
            </tridas:address>
        </tridas:laboratory>
        <tridas:category lang="en" normal="archaeology" normalId="1552" normalStd="DCCD">archeologie</tridas:category>
        <tridas:investigator>E. Jansma</tridas:investigator>
        <tridas:period>1993</tridas:period>
        <tridas:object>
            <tridas:title>TEST object</tridas:title>
            <tridas:identifier domain="stichtingring.nl">O:1993041:VEL</tridas:identifier>
            <tridas:createdTimestamp>2010-06-30T12:35:13Z</tridas:createdTimestamp>            <tridas:lastModifiedTimestamp>2010-06-30T12:35:13Z</tridas:lastModifiedTimestamp>
            <tridas:type lang="en" normal="Military camp" normalId="367" normalStd="DCCD">Legerplaats</tridas:type>
            <tridas:location>
                <tridas:locationGeometry>
                    <gml:Point srsName="WGS 84">
                        <gml:pos>%(lng)s %(lat)s</gml:pos>
                    </gml:Point>
                </tridas:locationGeometry>
            </tridas:location>
        </tridas:object>
    </tridas:project>
</tridas:tridas>	
"""
	#return template % {'lat':'4.6000','lng':'52.0000'}
	return template % {'title': title,'lat':str(lat),'lng':str(lng)}

"""
This function will recursively zip up a directory tree, compressing the files, and recording the correct relative filenames in the archive. The archive entries are the same as those generated by zip -r output.zip source_dir. 

Code from http://stackoverflow.com/questions/1855095/how-to-create-a-zip-archive-of-a-directory-in-python
"""
def make_zipfile(output_filename, source_dir):
	relroot = os.path.abspath(os.path.join(source_dir, ".."))
	#with zipfile.ZipFile(output_filename, "w", zipfile.ZIP_DEFLATED) as zip:
	# DISABLE compression
	# somehow the RESTfull interface with (Java) unzip can't handle
	# the compressed zip from Python...
	with zipfile.ZipFile(output_filename, "w") as zip:
		for root, dirs, files in os.walk(source_dir):
			# add directory (needed for empty dirs)
			zip.write(root, os.path.relpath(root, relroot))
			for file in files:
				filename = os.path.join(root, file)
				if os.path.isfile(filename): # regular files only
					arcname = os.path.join(os.path.relpath(root, relroot), file)
					zip.write(filename, arcname)
		zip.close()
					              
"""
 Create the project directory structure with the (xml) files
 
 projectfolder/
  |
  +-- metadata.xml
  |
  +-- data/
     |
     +-- tridas.xml
     |
     +-- associated/
     |  |
     |  +-- project.pdf
     |
     +-- values/
        |
        +-- heidelberg.fh
        
Use the index to vary the 'details' of the project
In this case the project name and the location on the map
"""
def createProject(i):
	lat = 52.0 + i*0.01
	lng = 4.0 + i*0.02
	projectName = "geotest" + str(i)
	
	projectFolderName = projectName
	# project folder
	pPath = os.path.join(outputDirName, projectFolderName)
	os.mkdir( pPath, 0755 )
	# metadata file
	metadataFile = open (os.path.join(pPath,"metadata.xml"), 'a')
	metadataFile.write(constructMetadata())
	metadataFile.close()
	# data folder
	dPath = os.path.join(pPath, "data")
	os.mkdir( dPath, 0755 )
	# tridas file
	tridasFile = open (os.path.join(dPath,"tridas.xml"), 'a')
	tridasFile.write(constructTridas(projectName, lat, lng))
	tridasFile.close()
	# associated and values when needed, but not yet!
	print "Created project in folder: " + projectFolderName
	#
	# create the zip file
	zipFilename = os.path.join(outputDirName, projectName+".zip")
	make_zipfile(zipFilename, pPath)

""" main """
def main(argv={}):
	#print(argv)
	#return
	
	global outputDirName

	if argv['-d']:
		outputDirName = argv['DIR']

	# create dir in not existent
	if not os.path.exists(outputDirName):
		os.mkdir(outputDirName, 0755 )
    
    # create the project folders
	numProjects = 100
	print "Starting creation of %d projects..."%numProjects
	for i in range(0, numProjects):
		print "Creating project (%d of %d) ..."%(i+1, numProjects) 
		createProject(i)
	print "Done"


if __name__ == '__main__':
    main(docopt(__doc__))
    